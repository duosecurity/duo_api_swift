//
//  Auth.swift
//  DuoAPISwift
//
//  Created by James Barclay on 7/27/16.
//  Copyright Â© 2022 Cisco Systems, Inc. and/or its affiliates. All rights reserved.
//
//  Duo Security Auth API reference client implementation.
//
//  http://www.duosecurity.com/docs/authapi

open class Auth: Client {
    /*
        Determine if the Duo service is up and responding.
     
        Returns information about the Duo service state: {
            'time': <int:UNIX timestamp>,
        }
     */
    open func ping(_ completion: @escaping (AnyObject) -> ()) {
        self.duoJSONAPICall("GET",
                            path: "/auth/v2/ping",
                            params: [:],
                            completion: { response in
                                completion(response)
            }
        )
    }
    
    /*
        Determine if the integration key, secret key, and signature
        generation are valid.
    
        Returns information about the Duo service state: {
            'time': <int:UNIX timestamp>,
        }
     */
    open func check(_ completion: @escaping (AnyObject) -> ()) {
        self.duoJSONAPICall("GET",
                            path: "/auth/v2/check",
                            params: [:],
                            completion: { response in
                                completion(response)
            }
        )
    }
    
    /*
        Retrieve the user-supplied logo.
     */
    open func logo(_ completion: @escaping (AnyObject) -> ()) {
        self.duoAPICall("GET",
                        path: "/auth/v2/logo",
                        params: [:],
                        completion: {
                            (data, httpResponse) in

                            if let contentType = httpResponse?.allHeaderFields["Content-Type"] as? String {
                                if contentType.hasPrefix("image/") {
                                    completion(data as AnyObject)
                                } else {
                                    completion(self.parseJSONResponse(data))
                                }
                            } else {
                                completion(self.parseJSONResponse(data))
                            }
            }
        )
    }
    
    /*
        Create a new user and associated numberless phone.
     
        Returns activation information: {
            'activation_barcode': <str:url>,
            'activation_code': <str:actcode>,
            'bypass_codes': <list[str:autogenerated]:optional>,
            'user_id': <str:autogenerated>,
            'username': <str:provided or autogenerated>,
            'valid_secs': <int:seconds>,
        }
     */
    open func enroll(_ username: String = "",
                       validSeconds: Int = 0,
                       bypassCodes: Int = 0,
                       completion: @escaping (AnyObject) -> ()) {
        var params: Dictionary<String, String> = [:]
        if username != "" {
            params["username"] = username
        }
        if validSeconds != 0 {
            params["valid_secs"] = String(validSeconds)
        }
        if bypassCodes != 0 {
            params["bypass_codes"] = String(bypassCodes)
        }
        self.duoJSONAPICall("POST",
                            path: "/auth/v2/enroll",
                            params: params as Dictionary<String, AnyObject>,
                            completion: { response in
                                completion(response)
            }
        )
    }
    
    /*
        Check if a user has been enrolled yet.
     
        Returns a string constant indicating whether the user has been
        enrolled or the code remains unclaimed.
     */
    open func enrollStatus(_ userID: String = "",
                             activationCode: String = "",
                             completion: @escaping (AnyObject) -> ()) {
        let params = [
            "user_id": userID,
            "activation_code": activationCode
        ]
        self.duoJSONAPICall("POST",
                            path: "/auth/v2/enroll_status",
                            params: params as Dictionary<String, AnyObject>,
                            completion: { response in
                                completion(response)
            }
        )
    }
    
    /*
        Determine if and with what factors a user may authenticate or enroll.
     
        See the adminapi docs for parameter and response information.
     */
    open func preAuth(_ username: String = "",
                        userID: String = "",
                        ipAddress: String = "",
                        trustedDeviceToken: String = "",
                        completion: @escaping (AnyObject) -> ()) {
        var params: Dictionary<String, String> = [:]
        if username != "" {
            params["username"] = username
        }
        if userID != "" {
            params["user_id"] = userID
        }
        if ipAddress != "" {
            params["ipaddr"] = ipAddress
        }
        if trustedDeviceToken != "" {
            params["trusted_device_token"] = trustedDeviceToken
        }
        self.duoJSONAPICall("POST",
                            path: "/auth/v2/preauth",
                            params: params as Dictionary<String, AnyObject>,
                            completion: { response in
                                completion(response)
            }
        )
    }
    
    /*
        Perform second-factor authentication for a user.
     
        If async is True, returns: {
            'txid': <str: transaction ID for use with auth_status>,
        }
     
        Otherwise, returns: {
            'result': <str:allow|deny>,
            'status': <str:machine-parsable>,
            'status_msg': <str:human-readable>,
        }
     
        If Trusted Devices is enabled, async is not true, and status is
        'allow', another item is returned:
     
        * trusted_device_token: <str: device token for use with preauth>
     */
    open func auth(_ factor: String,
                     username: String = "",
                     userID: String = "",
                     ipAddress: String = "",
                     asynchronous: Bool = false,
                     type: String = "",
                     displayUsername: String = "",
                     pushInfo: String = "",
                     device: String = "",
                     passcode: String = "",
                     completion: @escaping (AnyObject) -> ()) {
        var params = [
            "factor": factor,
            "async": asynchronous ? "1" : "0"
        ]
        if username != "" {
            params["username"] = username
        }
        if userID != "" {
            params["user_id"] = userID
        }
        if ipAddress != "" {
            params["ipaddr"] = ipAddress
        }
        if type != "" {
            params["type"] = type
        }
        if displayUsername != "" {
            params["display_username"] = displayUsername
        }
        if pushInfo != "" {
            params["pushinfo"] = pushInfo
        }
        if device != "" {
            params["device"] = device
        }
        if passcode != "" {
            params["passcode"] = passcode
        }
        self.duoJSONAPICall("POST",
                            path: "/auth/v2/auth",
                            params: params as Dictionary<String, AnyObject>,
                            completion: { response in
                                completion(response)
            }
        )
    }

    /*
        Longpoll for the status of an asynchronous authentication call.

        Returns a dict with four items:

        * waiting: True if the authentication attempt is still in progress
        and the caller can continue to poll, else False.

        * success: True if the authentication request has completed and
        was a success, else False.

        * status: String constant identifying the request's state.

        * status_msg: Human-readable string describing the request state.

        If Trusted Devices is enabled, another item is returned when success
        is True:

        * trusted_device_token: String token to bypass second-factor
          authentication for this user during an admin-defined period.
     */
    open func authStatus(_ txid: String, completion: @escaping (AnyObject) -> ()) {
        let params = [
            "txid": txid,
        ]
        self.duoJSONAPICall("GET",
                            path: "/auth/v2/auth_status",
                            params: params as Dictionary<String, AnyObject>,
                            completion: { response in
                                completion(response)
            }
        )
    }
}
